/*
    BSD 3-Clause License
    Copyright (c) 2023, Doosan Robotics Inc.
*/
import {
  Context,
  ModuleService,
  IModuleChannel,
  IProgramManager,
  ProgramSaveMode,
  Message,
  logger,
  IDartFileSystem,
  ModuleContext,
  SixNumArray,
} from 'dart-api';

//DRL Code.
import drlPath from './UserCommandDRL.drl';
import Database, { IDBData } from '../DatabaseManager';
import {
  CHANNEL_REQ_TO_SAVE_COMMANDS_DEF_AS_SUB_PROGRAM,
  CHANNEL_GEN_COMMAND_CALL,
} from './ChannelConstants';

//Sub program class
export default class UserCommandService extends ModuleService {
  private static readonly TAG = '[UserCommandService]';
  private db = {} as Database;

  /*****
   * Main Life Cycle
   * Constructor -> render -> ComponentDidMount -> componentDidUpdate -> OnBind
   *****/

  protected constructor(context: ModuleContext) {
    super(context);
    this.db = Database.getInstance(this.moduleContext);
  }

  // Check validity for usercommand_id1: -1 (Error), 0 (Invalid), 1 (Valid)
  // TODO: Customize this validation logic for your use case
  private getValidityForId1(data: any): number {
    // Check for errors (critical issues that prevent execution)
    if (data.waitTime < 0) {
      return -1; // Error: negative wait time
    }

    // Check initPose validity
    if (!data.initPose || !data.initPose.pose) {
      return -1; // Error: initPose not defined
    }

    // Check if initPose.pose is an array with 6 elements
    if (!Array.isArray(data.initPose.pose) || data.initPose.pose.length !== 6) {
      return -1; // Error: initPose must be array of 6 numbers
    }

    // Check if all pose values are valid numbers
    for (const value of data.initPose.pose) {
      if (typeof value !== 'number' || isNaN(value)) {
        return -1; // Error: invalid pose value
      }
    }

    // Check if useOverridePose is a boolean
    if (typeof data.useOverridePose !== 'boolean') {
      return -1; // Error: useOverridePose must be boolean
    }

    // TODO: Add invalid state checks (incomplete but not critical)
    // Example: if (data.someOptionalField === '') { return 0; }

    // All checks passed
    return 1; // Valid
  }

  // Check validity for usercommand_id2: -1 (Error), 0 (Invalid), 1 (Valid)
  // TODO: Customize this validation logic for your use case
  private getValidityForId2(data: any): number {
    // Check for errors (critical issues that prevent execution)
    // Check zyxPose validity
    if (!data.zyxPose) {
      return -1; // Error: zyxPose not defined
    }

    // Check if zyxPose is an array with 6 elements
    if (!Array.isArray(data.zyxPose) || data.zyxPose.length !== 6) {
      return -1; // Error: zyxPose must be array of 6 numbers
    }

    // Check if all pose values are valid numbers
    for (const value of data.zyxPose) {
      if (typeof value !== 'number' || isNaN(value)) {
        return -1; // Error: invalid pose value
      }
    }

    // Check for invalid states (incomplete but not critical)
    // Check if variable is selected
    if (data.variableSelected === '') {
      return 0; // Invalid: no variable selected
    }

    // All checks passed
    return 1; // Valid
  }

  // Check validity for Start/End Folder: -1 (Error), 0 (Invalid), 1 (Valid)
  // TODO: Customize this validation logic for your use case
  private getValidityForFolder(data: any): number {
    // Check for errors (critical issues that prevent execution)
    if (!data.folderName || data.folderName.trim() === '') {
      return -1; // Error: folder name is required
    }

    // Check if folderName is a valid string
    if (typeof data.folderName !== 'string') {
      return -1; // Error: folderName must be string
    }

    // Check if folderName contains only valid characters (alphanumeric and underscore)
    const validNamePattern = /^[a-zA-Z0-9_]+$/;
    if (!validNamePattern.test(data.folderName)) {
      return -1; // Error: folderName contains invalid characters
    }

    // All checks passed
    return 1; // Valid
  }

  //onBind
  onBind(message: Message, channel: IModuleChannel): boolean {
    logger.debug(
      `[${UserCommandService.TAG}] User command onBind: ${this.moduleContext.componentId}, ${JSON.stringify(
        message,
      )}`,
    );

    const programManager = this.moduleContext.getSystemManager(
      Context.PROGRAM_MANAGER,
    ) as IProgramManager;
    const fileSystem = this.moduleContext.getSystemLibrary(
      Context.DART_FILE_SYSTEM,
    ) as IDartFileSystem;

    /*********
     *   1. Event "req_to_save_commands_def_as_sub_program"
     *   Define and save Sub Program Function
     *   componentId : Screen component Id. Write in mainfest.json
     *   programName : The program name created by the taskeditor. It will automatically generated by the task editor.
     *********/
    channel.receive(
      CHANNEL_REQ_TO_SAVE_COMMANDS_DEF_AS_SUB_PROGRAM,
      async ({ programName }) => {
        try {
          logger.debug(`[${UserCommandService.TAG}] req_to_save_commands_def_as_sub_program: Sub_DRL check, Program Name = ${programName}`);

          // 1-1. Define Sub Program function
          let subProgram = `from DRCF import *\r\n`;

          const dbData = (await this.db.getDataAll()) as IDBData;
          subProgram += `Global_ip = "${dbData.ip}"\r\n`;
          subProgram += `Global_initPoseZyx = [${dbData.initPose.pose}]\r\n`;

          const drl = await fileSystem.readFile(this.moduleContext, drlPath);
          subProgram += drl;

          // 1-2. Save Sub Program function
          // logger.debug(`Sub_DRL : ${program}`);
          const result = await programManager.saveSubProgram(
            ProgramSaveMode.SAVE,
            programName,
            subProgram,
          );
          channel.send(CHANNEL_REQ_TO_SAVE_COMMANDS_DEF_AS_SUB_PROGRAM, result);

          // logger.debug(`Save Sub Program Result = ${result}`);
        } catch (error: any) {
          logger.error(`[${UserCommandService.TAG}] Error in req_to_save_commands_def_as_sub_program: ${error.message}`);
        }
      },
    );

    /*********
     *   2. Event "gen_command_call" (V2)
     *   Define function execute statement and send it to Task Editor
     *   componentId : Screen component Id. Write in mainfest.json
     *   data : Saved data. Received by PiP Screen.
     *********/
    channel.receive(CHANNEL_GEN_COMMAND_CALL, ({ componentId, data, endCommand }) => {
      try {
        //Execute statement for sub program

        /*************
         *  2-1. Generate execute statement
         *  Update Gripper Value and Make execute statement
         *  ex) result = 'function name(' + 'value1' + 'value2' + ... + 'last value' + ')'
         *  string value : Use JSON.stringify().
         *  boolean value : Use number().
         *  number value: Use as it is.
         *************/
        if (componentId === 'usercommand_id1') {
          // TODO: Customize DRL command generation for your function
          //usercommand_sample_function(waitTime, isMove, initPose)
          let command = 'usercommand_sample_function(';
          command += `${data.waitTime as number}, `;
          command += `${(data.useOverridePose as boolean) ? 'True' : 'False'}, `;
          command += `[${data.initPose.pose as SixNumArray}])`;

          logger.debug(
            `[${UserCommandService.TAG}] gen_command_call : ${command} , ComponentID = ${componentId}, data = ${JSON.stringify(
              data,
            )}`,
          );

          const validity = this.getValidityForId1(data);

          // V2 response format with validity and summary
          // summary: Displayed next to command in Task Tree
          const poseArray = data.initPose?.pose || [0, 0, 0, 0, 0, 0];
          const poseStr = `[${poseArray.map((v: number) => v.toFixed(1)).join(',')}]`;
          const response = {
            data: data,
            validity: validity,
            summary: `Wait ${data.waitTime}s, ${data.useOverridePose ? 'Custom' : 'Global'} pose ${poseStr}`, // TODO: Customize this message shown in Task Tree
            command: command,
          };

          channel.send(CHANNEL_GEN_COMMAND_CALL, response);
        }

        if (componentId === 'usercommand_id2') {
          // TODO: Customize DRL command generation for your function
          //usercommand_sample_calcXyzToZyz(zyxPose)
          let command = `usercommand_sample_calcXyzToZyz([${data.zyxPose}])`;

          logger.debug(
            `[${UserCommandService.TAG}] gen_command_call : ${command} , ComponentID = ${componentId}, data = ${JSON.stringify(
              data,
            )}`,
          );

          const validity = this.getValidityForId2(data);

          // V2 response format with validity and summary
          // summary: Displayed next to command in Task Tree
          const poseArray = data.zyxPose || [0, 0, 0, 0, 0, 0];
          const poseStr = `[${poseArray.map((v: number) => v.toFixed(1)).join(',')}]`;
          const response = {
            data: data,
            validity: validity,
            summary: data.variableSelected !== '' // TODO: Customize this message shown in Task Tree
              ? `Convert ${poseStr} â†’ ${data.variableSelected}`
              : `Convert ZYX ${poseStr} to ZYZ`,
            command: command,
            variableName: data.variableSelected !== '' ? data.variableSelected : undefined
          };

          channel.send(CHANNEL_GEN_COMMAND_CALL, response);
        }

        // Custom Folder (Start-End structure)
        if (componentId === 'usercommand_folder') {
          const validity = this.getValidityForFolder(data);

          // Check if this is End command (Task Editor automatically creates End command)
          if (endCommand) {
            // End Custom Folder - Task Editor will call this with endCommand: true
            // TODO: Customize DRL command generation for End command
            let command = 'usercommand_end_folder(';
            command += `${JSON.stringify(data.folderName)}`;
            command += ')';

            logger.debug(
              `[${UserCommandService.TAG}] gen_command_call (END) : ${command} , ComponentID = ${componentId}, data = ${JSON.stringify(
                data,
              )}`,
            );

            const response = {
              data: data,
              validity: validity,
              summary: `End Folder: ${data.folderName}`,
              command: command
            };

            channel.send(CHANNEL_GEN_COMMAND_CALL, response);
          } else {
            // Start Custom Folder
            // TODO: Customize DRL command generation for Start command
            let command = 'usercommand_start_folder(';
            command += `${JSON.stringify(data.folderName)}`;
            if (data.description && data.description.trim() !== '') {
              command += `, ${JSON.stringify(data.description)}`;
            }
            command += ')';

            logger.debug(
              `[${UserCommandService.TAG}] gen_command_call (START) : ${command} , ComponentID = ${componentId}, data = ${JSON.stringify(
                data,
              )}`,
            );

            const response = {
              data: data,
              validity: validity,
              summary: `Start Folder: ${data.folderName}${data.description ? ' - ' + data.description : ''}`,
              command: command
            };

            channel.send(CHANNEL_GEN_COMMAND_CALL, response);
          }
        }
      } catch (error: any) {
        logger.error(`[${UserCommandService.TAG}] Error in gen_command_call: ${error.message}`);
      }
    }); //channel.receive(gen_command_call)

    return true;
  } //onBind
} //ServiceForTaskEditor
